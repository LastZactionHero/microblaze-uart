/////******************************************************************************
////*
////* Copyright (C) 2009 - 2014 Xilinx, Inc.  All rights reserved.
////*
////* Permission is hereby granted, free of charge, to any person obtaining a copy
////* of this software and associated documentation files (the "Software"), to deal
////* in the Software without restriction, including without limitation the rights
////* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
////* copies of the Software, and to permit persons to whom the Software is
////* furnished to do so, subject to the following conditions:
////*
////* The above copyright notice and this permission notice shall be included in
////* all copies or substantial portions of the Software.
////*
////* Use of the Software is limited solely to applications:
////* (a) running on a Xilinx device, or
////* (b) that interact with a Xilinx device through a bus or interconnect.
////*
////* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
////* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
////* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
////* XILINX  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
////* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
////* OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
////* SOFTWARE.
////*
////* Except as contained in this notice, the name of the Xilinx shall not be used
////* in advertising or otherwise to promote the sale, use or other dealings in
////* this Software without prior written authorization from Xilinx.
////*
////******************************************************************************/
////
/////*
//// * helloworld.c: simple test application
//// *
//// * This application configures UART 16550 to baud rate 9600.
//// * PS7 UART (Zynq) is not initialized by this application, since
//// * bootrom/bsp configures it to baud rate 115200
//// *
//// * ------------------------------------------------
//// * | UART TYPE   BAUD RATE                        |
//// * ------------------------------------------------
//// *   uartns550   9600
//// *   uartlite    Configurable only in HW design
//// *   ps7_uart    115200 (configured by bootrom/bsp)
//// */
////
////#include <stdio.h>
////#include "platform.h"
////#include "xil_printf.h"
////
////
////int main()
////{
////    init_platform();
////
////    print("Hello World\n\r");
////
////    cleanup_platform();
////    return 0;
////}
//
//#include <xuartlite_l.h>
//#include <xintc_l.h>
//
///* uartlite interrupt service routine */
//void uart_int_handler(void *baseaddr_p) {
//	char c;
//	/* till uart FIFOs are empty */
//	while (!XUartLite_IsReceiveEmpty(XPAR_AXI_UARTLITE_0_BASEADDR)) {
//		/* read a character */
//		c = XUartLite_RecvByte(XPAR_AXI_UARTLITE_0_BASEADDR);
//		/* print character on hyperterminal (STDOUT) */
//		xil_printf ("Character: %c \r\n", c);
//	}
//}
//
//int main(void)
//{
//	/* Enable MicroBlaze exception */
//   microblaze_enable_interrupts();
//
//	/* Connect uart interrupt handler that will be called when an interrupt
//	* for the uart occurs*/
//	XIntc_RegisterHandler(
//			XPAR_INTC_0_BASEADDR,
//			XPAR_MICROBLAZE_0_AXI_INTC_AXI_UARTLITE_0_INTERRUPT_INTR,
//			(XInterruptHandler)uart_int_handler,
//			(void *)XPAR_AXI_UARTLITE_0_BASEADDR
//	);
//
//	/* Start the interrupt controller */
//	XIntc_MasterEnable(XPAR_INTC_0_BASEADDR);
//
//	/* Enable uart interrupt in the interrupt controller */
//	XIntc_EnableIntr(XPAR_INTC_0_BASEADDR, XPAR_AXI_UARTLITE_0_INTERRUPT_MASK);
//
//	/* Enable Uartlite interrupt */
//	XUartLite_EnableIntr(XPAR_AXI_UARTLITE_0_BASEADDR);
//
//	xil_printf("Here\r\n");
//	/* Wait for interrupts to occur */
//	while (1);
//}

#include <xuartlite_l.h>
#include <xgpio.h>
#include <xintc_l.h>
#include <xparameters.h>

/* uartlite interrupt service routine */
void uart_int_handler(void *baseaddr_p) {
	char c;
	/* till uart FIFOs are empty */
	while (!XUartLite_IsReceiveEmpty(XPAR_AXI_UARTLITE_0_BASEADDR)) {
		/* read a character */
		c = XUartLite_RecvByte(XPAR_AXI_UARTLITE_0_BASEADDR);
		/* print character on hyperterminal (STDOUT) */
		xil_printf ("%c", c);
	}
}

int main(void)
{
	xil_printf("Started\r\n");

	XGpio gpio;
//	int XGpio_Initialize(XGpio *InstancePtr, u16 DeviceId);
	int XGpio_Initialize(&gpio, XPAR_AXI_GPIO_0_DEVICE_ID);

	void XGpio_SetDataDirection(XGpio *InstancePtr, unsigned Channel,
				    u32 DirectionMask);
	void XGpio_DiscreteWrite(XGpio *InstancePtr, unsigned Channel, u32 Mask);

	/* Enable MicroBlaze exception */
	microblaze_enable_interrupts();

	/* Connect uart interrupt handler that will be called when an interrupt
	 * for the uart occurs*/
	XIntc_RegisterHandler(
			XPAR_INTC_0_BASEADDR,
			XPAR_MICROBLAZE_0_AXI_INTC_AXI_UARTLITE_0_INTERRUPT_INTR,
			(XInterruptHandler)uart_int_handler,
			(void *)XPAR_AXI_UARTLITE_0_BASEADDR
	);

	/* Start the interrupt controller */
	XIntc_MasterEnable(XPAR_INTC_0_BASEADDR);

	/* Enable uart interrupt in the interrupt controller */
	XIntc_EnableIntr(XPAR_INTC_0_BASEADDR, XPAR_AXI_UARTLITE_0_INTERRUPT_MASK);

	/* Enable Uartlite interrupt */
	XUartLite_EnableIntr(XPAR_AXI_UARTLITE_0_BASEADDR);


	/* Wait for interrupts to occur */
	while (1);
}
